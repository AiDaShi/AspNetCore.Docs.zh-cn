---
title: 利用 ASP.NET Core Blazor WebAssembly 生成渐进式 Web 应用程序
author: guardrex
description: 了解如何生成基于 Blazor 的渐进式 Web 应用程序 (PWA)，即使用新式浏览器功能以表现得如桌面应用的 Web 应用。
monikerRange: '>= aspnetcore-3.1'
ms.author: riande
ms.custom: mvc
ms.date: 03/09/2020
no-loc:
- Blazor
- SignalR
uid: blazor/progressive-web-app
ms.openlocfilehash: f1c1ce50f20bf579e67e1d4eb02cc7d9d681e354
ms.sourcegitcommit: 98bcf5fe210931e3eb70f82fd675d8679b33f5d6
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/11/2020
ms.locfileid: "79083559"
---
# <a name="build-progressive-web-applications-with-aspnet-core-opno-locblazor-webassembly"></a><span data-ttu-id="ed4ae-103">利用 ASP.NET Core Blazor WebAssembly 生成渐进式 Web 应用程序</span><span class="sxs-lookup"><span data-stu-id="ed4ae-103">Build Progressive Web Applications with ASP.NET Core Blazor WebAssembly</span></span>

<span data-ttu-id="ed4ae-104">作者：[Steve Sanderson](https://github.com/SteveSandersonMS)</span><span class="sxs-lookup"><span data-stu-id="ed4ae-104">By [Steve Sanderson](https://github.com/SteveSandersonMS)</span></span>

[!INCLUDE[](~/includes/blazorwasm-preview-notice.md)]

[!INCLUDE[](~/includes/blazorwasm-3.2-template-article-notice.md)]

<span data-ttu-id="ed4ae-105">渐进式 Web 应用程序 (PWA) 是一种基于 Web 的应用程序，它使用新式浏览器 API 和功能以表现得如桌面应用程序。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-105">A Progressive Web Application (PWA) is a web-based application that uses modern browser APIs and capabilities to behave like a desktop application.</span></span> <span data-ttu-id="ed4ae-106">这些功能包括：</span><span class="sxs-lookup"><span data-stu-id="ed4ae-106">These capabilities can include:</span></span>

* <span data-ttu-id="ed4ae-107">脱机工作并始终即时加载（不受网络速度影响）</span><span class="sxs-lookup"><span data-stu-id="ed4ae-107">Working offline and always loading instantly, independently of network speed</span></span>
* <span data-ttu-id="ed4ae-108">能够在其自己的应用程序窗口中（而不只是在浏览器窗口中）运行</span><span class="sxs-lookup"><span data-stu-id="ed4ae-108">Being able to run in its own application window, not just a browser window</span></span>
* <span data-ttu-id="ed4ae-109">从主机操作系统 (OS) 的开始菜单、扩展坞或主屏幕启动</span><span class="sxs-lookup"><span data-stu-id="ed4ae-109">Being launched from the host operating system (OS) start menu, dock, or home screen</span></span>
* <span data-ttu-id="ed4ae-110">从后端服务器接收推送通知，即使用户没有在使用应用程序</span><span class="sxs-lookup"><span data-stu-id="ed4ae-110">Receiving push notifications from a backend server, even while the user is not using the application</span></span>
* <span data-ttu-id="ed4ae-111">在后台自动更新</span><span class="sxs-lookup"><span data-stu-id="ed4ae-111">Automatically updating in the background</span></span>

<span data-ttu-id="ed4ae-112">用户可能会首先在 Web 浏览器中发现并使用该应用程序，就像其他任何单页应用程序 (SPA) 一样，然后再逐步将其安装到 OS 中并启用推送通知。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-112">A user might first discover and use the application within their web browser like any other single-page application (SPA), then later progress to installing it in their OS and enabling push notifications.</span></span> <span data-ttu-id="ed4ae-113">这就是我们使用术语“渐进式”的原因。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-113">That's why we use the term *progressive*.</span></span>

Blazor<span data-ttu-id="ed4ae-114"> WebAssembly 是真正的基于标准的客户端 Web 应用程序平台，因此它可以使用任何浏览器 API，包括上面列出的功能所需的 PWA API。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-114"> WebAssembly is a true standards-based client-side web application platform, so it can use any browser API, including PWA APIs needed for the capabilities listed above.</span></span> <span data-ttu-id="ed4ae-115">与任何其他客户端 Web 技术一样，它可以脱机工作。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-115">It can work offline just like any other client-side web technology.</span></span>

## <a name="pwa-template"></a><span data-ttu-id="ed4ae-116">PWA 模板</span><span class="sxs-lookup"><span data-stu-id="ed4ae-116">PWA template</span></span>

<span data-ttu-id="ed4ae-117">创建新的 Blazor WebAssembly 应用程序时，你可选择添加 PWA 功能。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-117">When creating a new Blazor WebAssembly application, you are offered the option to add PWA features.</span></span> <span data-ttu-id="ed4ae-118">在 Visual Studio 中，该选项在项目创建对话框中以复选框形式提供：</span><span class="sxs-lookup"><span data-stu-id="ed4ae-118">In Visual Studio, the option is given as a checkbox in the project creation dialog:</span></span>

![图像](https://user-images.githubusercontent.com/1101362/76207411-a6b54200-61f5-11ea-9dfc-6acd87a91428.png)

<span data-ttu-id="ed4ae-120">如果要在命令行上创建项目，可以使用 `--pwa` 标志。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-120">If you're creating the project on the command line, you can use the `--pwa` flag.</span></span> <span data-ttu-id="ed4ae-121">例如，应用于对象的</span><span class="sxs-lookup"><span data-stu-id="ed4ae-121">For example,</span></span>

```dotnetcli
dotnet new blazorwasm --pwa -o MyNewProject
```

<span data-ttu-id="ed4ae-122">在这两种情况下，你可根据需要将其与“托管的 ASP.NET Core”选项结合使用，但不一定非要这样做。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-122">In both cases, you're free to combine this with the "ASP.NET Core hosted" option if you wish, but don't have to do so.</span></span> <span data-ttu-id="ed4ae-123">PWA 功能独立于托管模型。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-123">PWA features are independent of the hosting model.</span></span>

## <a name="installation-and-app-manifest"></a><span data-ttu-id="ed4ae-124">安装和应用部件清单 (manifest)</span><span class="sxs-lookup"><span data-stu-id="ed4ae-124">Installation and app manifest</span></span>

<span data-ttu-id="ed4ae-125">访问使用 PWA 模板选项创建的应用程序时，用户可以选择将应用程序安装到其 OS 的开始菜单、扩展坞或主屏幕。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-125">When visiting an application created using the PWA template option, users have the option to install the application into their OS's start menu, dock, or home screen.</span></span>

<span data-ttu-id="ed4ae-126">此选项的显示方式取决于用户的浏览器。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-126">The way this option is presented depends on the user's browser.</span></span> <span data-ttu-id="ed4ae-127">例如，使用基于桌面 Chromium 的浏览器（如 Edge 或 Chrome）时，URL 栏中会出现“添加”按钮：</span><span class="sxs-lookup"><span data-stu-id="ed4ae-127">For example, when using desktop Chromium-based browsers such as Edge or Chrome, an *Add* button appears within the URL bar:</span></span>

![图像](https://user-images.githubusercontent.com/1101362/76208127-f7796a80-61f6-11ea-8aea-7fba704be787.png)

<span data-ttu-id="ed4ae-129">在 iOS 上，访问者可以通过 Safari 的“共享”按钮和“添加到主屏幕”选项安装 PWA。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-129">On iOS, visitors can install the PWA using Safari's *Share* button and its *Add to Homescreen* option.</span></span> <span data-ttu-id="ed4ae-130">在适用于 Android 的 Chrome 上，用户应该点击右上角的“菜单”按钮，然后选择“添加到主屏幕”。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-130">On Chrome for Android, users should tap the *Menu* button in the upper-right corner, then choose *Add to Home screen*.</span></span>

<span data-ttu-id="ed4ae-131">安装后，应用程序将显示在其自己的窗口中，没有任何地址栏。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-131">Once installed, the application appears in its own window, without any address bar.</span></span>

![图像](https://user-images.githubusercontent.com/1101362/76208588-e2e9a200-61f7-11ea-85e1-8c3fc849b252.png)

<span data-ttu-id="ed4ae-133">若要自定义窗口的标题、配色方案、图标或其他详细信息，请参阅项目 wwwroot 目录中的 `manifest.json` 文件。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-133">To customize the window's title, color scheme, icon, or other details, see the file `manifest.json` in your project's *wwwroot* directory.</span></span> <span data-ttu-id="ed4ae-134">此文件的架构由 Web 标准定义。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-134">The schema of this file is defined by web standards.</span></span> <span data-ttu-id="ed4ae-135">有关详细文档，请参阅 https://developer.mozilla.org/docs/Web/Manifest。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-135">For detailed documentation, see https://developer.mozilla.org/docs/Web/Manifest.</span></span>

## <a name="offline-support"></a><span data-ttu-id="ed4ae-136">脱机支持</span><span class="sxs-lookup"><span data-stu-id="ed4ae-136">Offline support</span></span>

<span data-ttu-id="ed4ae-137">默认情况下，使用 PWA 模板选项创建的应用程序支持脱机运行。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-137">By default, applications created using the PWA template option have support for running offline.</span></span> <span data-ttu-id="ed4ae-138">用户必须先在联机时访问该应用程序，然后浏览器将自动下载并缓存脱机操作所需的所有资源。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-138">A user must first visit the application while they are online, then the browser will automatically download and cache all the resources needed to operate offline.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="ed4ae-139">脱机支持只对已发布的应用程序启用。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-139">Offline support is only enabled for *published* applications.</span></span> <span data-ttu-id="ed4ae-140">它在开发过程中未启用。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-140">It is not enabled during development.</span></span> <span data-ttu-id="ed4ae-141">这是因为它会干扰常规开发周期（进行更改和测试更改）。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-141">This is because it would interfere with the usual development cycle of making changes and testing them.</span></span>

> [!WARNING]
> <span data-ttu-id="ed4ae-142">如果你打算交付启用脱机的 PWA，则需要了解[几个重要的警告和注意事项](#caveats-for-offline-pwas)。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-142">If you intend to ship an offline-enabled PWA, there are [several important warnings and caveats](#caveats-for-offline-pwas) you need to understand.</span></span> <span data-ttu-id="ed4ae-143">这些是脱机 PWA 所固有的，而不是特定于 Blazor。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-143">These are inherent to offline PWAs, and not specific to Blazor.</span></span> <span data-ttu-id="ed4ae-144">在对启用了脱机的应用程序的工作方式做出假设之前，请务必阅读并了解这些注意事项。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-144">Be sure to read and understand these caveats before making assumptions about how your offline-enabled application will work.</span></span>

<span data-ttu-id="ed4ae-145">若要查看脱机支持的工作方式，请首先[发布应用程序](https://docs.microsoft.com/aspnet/core/host-and-deploy/blazor/?view=aspnetcore-3.1&tabs=visual-studio#publish-the-app)，并将其托管在支持 HTTPS 的服务器上。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-145">To see how offline support works, first [publish your application](https://docs.microsoft.com/aspnet/core/host-and-deploy/blazor/?view=aspnetcore-3.1&tabs=visual-studio#publish-the-app), and host it on a server supporting HTTPS.</span></span> <span data-ttu-id="ed4ae-146">访问应用程序时，你应该能够打开浏览器的开发工具，并验证是否为主机注册了“服务工作进程”：</span><span class="sxs-lookup"><span data-stu-id="ed4ae-146">When you visit the application, you should be able to open the browser's dev tools and verify that a *Service Worker* is registered for your host:</span></span>

![图像](https://user-images.githubusercontent.com/1101362/76210294-bd5e9780-61fb-11ea-9869-65c55c62803d.png)

<span data-ttu-id="ed4ae-148">此外，如果你重载页面，则在“网络”选项卡上，你应可看到加载页面所需的所有资源都是从“服务工作进程”或“内存缓存”检索的：</span><span class="sxs-lookup"><span data-stu-id="ed4ae-148">Additionally, if you reload the page, then on the *Network* tab you should see that all resources needed to load your page are being retrieved from the *Service Worker* or *Memory Cache*:</span></span>

![图像](https://user-images.githubusercontent.com/1101362/76210472-1d553e00-61fc-11ea-84c6-291644df709e.png)

<span data-ttu-id="ed4ae-150">这表明，浏览器不依赖于网络访问来加载应用程序。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-150">This shows that the browser is not dependent on network access to load your application.</span></span> <span data-ttu-id="ed4ae-151">若要验证这一点，你可关闭 Web 服务器，或指示浏览器模拟脱机模式：</span><span class="sxs-lookup"><span data-stu-id="ed4ae-151">To verify this, you can either shut down your web server, or instruct the browser to simulate offline mode:</span></span>

![图像](https://user-images.githubusercontent.com/1101362/76210556-47a6fb80-61fc-11ea-9d12-20a8f6528744.png)

<span data-ttu-id="ed4ae-153">现在，即使无法访问 Web 服务器，你也应能够重载页面，并查看应用程序是否仍在加载和运行。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-153">Now, even without access to your web server, you should be able to reload the page and see that your application still loads and runs.</span></span> <span data-ttu-id="ed4ae-154">同样，即使你模拟非常缓慢的网络连接，页面仍会立即加载，因为它是独立于网络而加载的。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-154">Likewise, even if you simulate a very slow network connection, your page will still load immediately since it is loaded independently of the network.</span></span>

### <a name="service-worker"></a><span data-ttu-id="ed4ae-155">服务工作进程</span><span class="sxs-lookup"><span data-stu-id="ed4ae-155">Service worker</span></span>

<span data-ttu-id="ed4ae-156">脱机支持可通过服务工作进程实现。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-156">Offline support is achieved using a service worker.</span></span> <span data-ttu-id="ed4ae-157">这是一种 Web 标准，不特定于 Blazor。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-157">This is a web standard, not specific to Blazor.</span></span> <span data-ttu-id="ed4ae-158">有关服务工作进程的文档，请参阅 https://developer.mozilla.org/docs/Web/API/Service_Worker_API。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-158">For documentation about service workers, see https://developer.mozilla.org/docs/Web/API/Service_Worker_API.</span></span> <span data-ttu-id="ed4ae-159">若要了解有关服务工作进程的常见使用模式的详细信息，请参阅这篇精彩文章 - [服务工作进程生命周期](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle)。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-159">To learn more about common usage patterns for service workers, see the excellent article [The Service Worker Lifecycle](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle).</span></span>

Blazor<span data-ttu-id="ed4ae-160"> 的 PWA 模板产生两个服务工作进程文件：</span><span class="sxs-lookup"><span data-stu-id="ed4ae-160">'s PWA template produces two service worker files:</span></span>

* <span data-ttu-id="ed4ae-161">在开发过程中使用的 wwwroot/service-worker.js</span><span class="sxs-lookup"><span data-stu-id="ed4ae-161">*wwwroot/service-worker.js*, which is used during development</span></span>
* <span data-ttu-id="ed4ae-162">在发布应用程序后使用的 wwwroot/service-worker.published.js</span><span class="sxs-lookup"><span data-stu-id="ed4ae-162">*wwwroot/service-worker.published.js*, which is used once your application is published</span></span>

<span data-ttu-id="ed4ae-163">如果要在这两个文件之间共享逻辑，请考虑添加第三个 JavaScript 文件来保存公用逻辑，并使用 [`self.importScripts`](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/importScripts) 将该逻辑加载到这两个文件中。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-163">If you want to share logic between these two files, consider adding a third JavaScript file to hold the common logic, and use [`self.importScripts`](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/importScripts) to load that logic into both files.</span></span>

#### <a name="cache-first-fetch-strategy"></a><span data-ttu-id="ed4ae-164">缓存优先提取策略</span><span class="sxs-lookup"><span data-stu-id="ed4ae-164">Cache-first fetch strategy</span></span>

<span data-ttu-id="ed4ae-165">内置 service-worker.published.js 服务工作进程使用“缓存优先”策略来解析请求。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-165">The built-in *service-worker.published.js* service worker resolves requests using a *cache-first* strategy.</span></span> <span data-ttu-id="ed4ae-166">这意味着，无论用户是否有网络访问权限或服务器上是否有更新的内容，它始终优先返回缓存的内容（如果有）。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-166">This means it always prefers to return cached content if available, regardless of whether the user has network access or whether newer content is available on the server.</span></span>

<span data-ttu-id="ed4ae-167">它的价值体现在以下两点：</span><span class="sxs-lookup"><span data-stu-id="ed4ae-167">There are two reasons why this is valuable:</span></span>

* <span data-ttu-id="ed4ae-168">它可确保可靠性。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-168">**It ensures reliability.**</span></span> <span data-ttu-id="ed4ae-169">网络访问不是布尔状态。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-169">Network access is not a boolean state.</span></span> <span data-ttu-id="ed4ae-170">用户不只是“联机”或“脱机”。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-170">A user is not simply "online" or "offline".</span></span> <span data-ttu-id="ed4ae-171">事实上，用户的设备可能认为它处于联机状态，但可能由于网络速度太慢，根本无法加载。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-171">In reality, the user's device may believe it is online, but the network may be so slow as to be impractical to wait for.</span></span> <span data-ttu-id="ed4ae-172">或者，网络可能会对某些 URL 返回无效结果（例如，当有一个强制 WIFI 门户当前正在阻止或重定向某些请求时）。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-172">Or the network might be returning invalid results for certain URLs, such as when there is a captive WIFI portal that is currently blocking or redirecting certain requests.</span></span> <span data-ttu-id="ed4ae-173">这就是浏览器的 `navigator.onLine` API 不可靠并且不应依赖的原因。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-173">This is why the browser's `navigator.onLine` API is not reliable and should not be depended upon.</span></span>
* <span data-ttu-id="ed4ae-174">它可确保正确性。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-174">**It ensures correctness.**</span></span> <span data-ttu-id="ed4ae-175">在生成脱机资源的缓存时，服务工作进程使用内容哈希，确保它在某个时刻提取了完整且自身一致的资源快照。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-175">When building a cache of offline resources, the service worker uses content hashing to guarantee it has fetched a complete and self-consistent snapshot of resources at a single instant in time.</span></span> <span data-ttu-id="ed4ae-176">此缓存随后用作原子单元。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-176">This cache is then used as an atomic unit.</span></span> <span data-ttu-id="ed4ae-177">鉴于此，没有必要向网络请求更新的资源，因为你唯一需要的版本是已经缓存的版本。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-177">Given this, there is no point asking the network for newer resources, since the only versions you want are the ones you've already cached.</span></span> <span data-ttu-id="ed4ae-178">其他任何版本都会产生不一致和不兼容的风险（例如，尝试使用未一起编译的 .NET 程序集的版本）。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-178">Anything else risks inconsistency and incompatibility (for example, trying to use versions of .NET assemblies that were not compiled together).</span></span>

#### <a name="background-updates"></a><span data-ttu-id="ed4ae-179">后台更新</span><span class="sxs-lookup"><span data-stu-id="ed4ae-179">Background updates</span></span>

<span data-ttu-id="ed4ae-180">作为一种思维模型，你可以将脱机优先 PWA 的行为视为与可安装的移动应用类似。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-180">As a mental model, you can think of an offline-first PWA as behaving like an mobile app that can be installed.</span></span> <span data-ttu-id="ed4ae-181">无论网络连接情况如何，它都会立即启动，但是已安装的应用程序逻辑来自可能不是最新版本的时间点快照。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-181">It always starts up immediately regardless of network connectivity, but the installed application logic comes from a point-in-time snapshot that might not be the latest version.</span></span>

<span data-ttu-id="ed4ae-182">Blazor PWA 模板生成的应用程序会在用户访问和具有正在工作的网络连接时，自动尝试在后台进行自我更新。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-182">The Blazor PWA template produces applications that automatically try to update themselves in the background whenever the user visits and has a working network connection.</span></span> <span data-ttu-id="ed4ae-183">其工作方式如下所示：</span><span class="sxs-lookup"><span data-stu-id="ed4ae-183">The way this works is as follows:</span></span>

* <span data-ttu-id="ed4ae-184">在编译期间，你的项目将生成“服务工作进程资产清单”。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-184">During compilation, your project generates a *service worker assets manifest*.</span></span> <span data-ttu-id="ed4ae-185">默认情况下，这称为 service-worker-assets.js。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-185">By default this is called *service-worker-assets.js*.</span></span> <span data-ttu-id="ed4ae-186">这列出了应用程序脱机工作所需的所有静态资源，如 .NET 程序集、JavaScript 文件、CSS 等，包括其内容哈希。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-186">This lists all the static resources your application needs to function offline, such as .NET assemblies, JavaScript files, CSS, etc., including their content hashes.</span></span> <span data-ttu-id="ed4ae-187">此列表由服务工作进程加载，这样它便知道要缓存哪些资源。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-187">This list is loaded by your service worker so that it knows which resources to cache.</span></span>
* <span data-ttu-id="ed4ae-188">用户每次访问应用程序时，浏览器会在后台重新请求 service-worker.js 和 service-worker-assets.js。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-188">Each time the user visits your application, the browser re-requests *service-worker.js* and *service-worker-assets.js* in the background.</span></span> <span data-ttu-id="ed4ae-189">如果服务器为这些文件中的任一文件返回更改的内容（与现有已安装的服务工作进程进行逐字节比较），则服务工作进程将尝试安装其自身的新版本。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-189">If the server returns changed content for either of these files (compared byte-for-byte with the existing installed service worker), the service worker tries to install a new version of itself.</span></span>
* <span data-ttu-id="ed4ae-190">安装自身的新版本时，服务工作进程将为脱机资源创建新的独立缓存，并开始使用 service-worker-assets.js 中列出的资源填充该缓存。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-190">When installing a new version of itself, the service worker creates a new, separate cache for offline resources, and starts populating it with resources listed in *service-worker-assets.js*.</span></span> <span data-ttu-id="ed4ae-191">此逻辑在 service-worker.published.js 内的 `onInstall` 函数中实现。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-191">This logic is implemented in the `onInstall` function inside *service-worker.published.js*.</span></span>
* <span data-ttu-id="ed4ae-192">如果该过程成功完成（即，所有资源都加载无误，所有内容哈希都匹配），则新的服务工作进程将进入“正在等待激活”状态。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-192">If the process completes successfully (i.e., all the resources are loaded without error, and all content hashes match), then the new service worker enters a "waiting for activation" state.</span></span> <span data-ttu-id="ed4ae-193">一旦用户关闭应用程序（即，没有剩余的选项卡或窗口显示应用程序），则新的服务工作进程将变为“活动”，并将用于对应用程序的后续访问。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-193">As soon as the user closes your application (i.e., there are no remaining tabs or windows displaying your application), the new service worker becomes "active" and will be used for subsequent visits to your application.</span></span> <span data-ttu-id="ed4ae-194">旧服务工作进程及其缓存被删除。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-194">The old service worker and its cache are deleted.</span></span>
* <span data-ttu-id="ed4ae-195">如果该过程未成功完成，则弃用新的服务工作进程实例。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-195">If the process does not complete successfully, the new service worker instance is discarded.</span></span> <span data-ttu-id="ed4ae-196">用户下次访问时将再次尝试此更新过程，届时用户最好使用更好的网络连接来完成请求。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-196">The update process will be attempted again on the user's next visit, when hopefully they have a better network connection that can complete the requests.</span></span>

<span data-ttu-id="ed4ae-197">你可以通过编辑服务工作进程逻辑来自定义此过程的任何方面。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-197">You can customize any aspect of this process by editing the service worker logic.</span></span> <span data-ttu-id="ed4ae-198">以上均不特定于 Blazor，只是 PWA 模板选项提供的建议。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-198">None of the above is specific to Blazor, but is merely a suggestion provided by the PWA template option.</span></span> <span data-ttu-id="ed4ae-199">有关详细信息，请参阅[服务工作进程文档](https://developer.mozilla.org/docs/Web/API/Service_Worker_API.)。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-199">See [service worker documentation](https://developer.mozilla.org/docs/Web/API/Service_Worker_API.) for more information.</span></span>

#### <a name="how-requests-are-resolved"></a><span data-ttu-id="ed4ae-200">如何解析请求</span><span class="sxs-lookup"><span data-stu-id="ed4ae-200">How requests are resolved</span></span>

<span data-ttu-id="ed4ae-201">如上所述，默认服务工作进程使用缓存优先策略，这意味着它会尽量提供缓存的内容（如果有）。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-201">As described above, the default service worker uses a *cache-first* strategy, meaning that it tries to serve cached content when available.</span></span> <span data-ttu-id="ed4ae-202">如果没有对某个 URL 缓存任何内容（例如，从后端 API 请求数据时），则服务工作进程回退到定期网络请求，该请求仅在服务器可访问时才会成功。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-202">If there is no content cached for a certain URL, for example when requesting data from a backend API, the service worker falls back on a regular network request which can only succeed if the server is reachable.</span></span> <span data-ttu-id="ed4ae-203">此逻辑在 service-worker.published.js 内的 `onFetch` 中实现。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-203">This logic is implemented inside `onFetch` within *service-worker.published.js*.</span></span>

<span data-ttu-id="ed4ae-204">如果你的 Blazor 组件依赖于从后端 API 请求数据，并且你想要在此类请求由于网络不可用而失败的情况下提供友好的用户体验，则需要在组件中实现逻辑。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-204">If your Blazor components rely on requesting data from backend APIs, and you want to provide a friendly user experience in the case where such requests fail due to network unavailability, then you need to implement logic within your components.</span></span> <span data-ttu-id="ed4ae-205">例如，对 `HttpClient` 请求使用 `try/catch`。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-205">For example, use `try/catch` around `HttpClient` requests.</span></span>

#### <a name="support-server-rendered-pages"></a><span data-ttu-id="ed4ae-206">支持服务器呈现的页面</span><span class="sxs-lookup"><span data-stu-id="ed4ae-206">Support server-rendered pages</span></span>

<span data-ttu-id="ed4ae-207">仔细想想用户第一次导航到应用程序中的 URL（如 `/counter`）或任何其他深层链接时会发生什么情况。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-207">Consider what happens when the user first navigates to a URL such as `/counter` or any other deep link into your application.</span></span> <span data-ttu-id="ed4ae-208">在这些情况下，你不希望返回缓存为 `/counter` 的内容，而是需要浏览器加载缓存为 `/index.html` 的内容，以启动 Blazor WebAssembly 应用程序。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-208">In these cases, you don't want to return content cached as `/counter`, but instead need the browser to load the content cached as `/index.html` to start up your Blazor WebAssembly application.</span></span> <span data-ttu-id="ed4ae-209">这些初始请求称为“导航”请求（与图像/CSS 等的子资源请求或 API 数据的提取/XHR 请求相对）。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-209">These initial requests are known as *navigation* requests (as opposed to *subresource* requests for images/CSS/etc, or *fetch/XHR* requests for API data).</span></span>

<span data-ttu-id="ed4ae-210">默认服务工作进程包含导航请求的特例逻辑。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-210">The default service worker contains special-case logic for navigation requests.</span></span> <span data-ttu-id="ed4ae-211">它通过返回 `/index.html` 的缓存内容来解析这些请求，而不管请求的 URL 是什么。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-211">It resolves them by returning the cached content for `/index.html`, regardless of the requested URL.</span></span> <span data-ttu-id="ed4ae-212">此逻辑在 service-worker.published.js 内的 `onFetch` 函数中实现。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-212">This logic is implemented in the `onFetch` function inside *service-worker.published.js*.</span></span>

<span data-ttu-id="ed4ae-213">如果应用程序具有必须返回服务器呈现的 HTML 的某些 URL（而不是从缓存中提供 `/index.html`），则你需要在服务工作进程中编辑该逻辑。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-213">If your application has certain URLs that must return server-rendered HTML (and not serve `/index.html` from the cache), then you need to edit the logic in your service worker.</span></span> <span data-ttu-id="ed4ae-214">例如，如果所有包含 `/Identity/` 的 URL 都需要作为对服务器的常规仅联机请求来处理，则需修改 service-worker.published.js `onFetch` 逻辑。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-214">For example, if all URLs containing `/Identity/` need to be handled as regular online-only requests to the server, then modify *service-worker.published.js* `onFetch` logic.</span></span> <span data-ttu-id="ed4ae-215">找到下列代码：</span><span class="sxs-lookup"><span data-stu-id="ed4ae-215">Locate the following code:</span></span>

```javascript
const shouldServeIndexHtml = event.request.mode === 'navigate';
```

<span data-ttu-id="ed4ae-216">将代码更改为以下内容：</span><span class="sxs-lookup"><span data-stu-id="ed4ae-216">Change the code to the following:</span></span>

```javascript
const shouldServeIndexHtml = event.request.mode === 'navigate'
    && !event.request.url.includes('/Identity/');
```

<span data-ttu-id="ed4ae-217">如果你不执行此操作，则无论网络连接情况如何，服务工作进程都将截获此类 URL 的请求，并使用 `/index.html` 解析这些请求。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-217">If you don't do this, then regardless of network connectivity, the service worker will intercept requests for such URLs and will resolve them using `/index.html`.</span></span>

#### <a name="control-asset-caching"></a><span data-ttu-id="ed4ae-218">控制资产缓存</span><span class="sxs-lookup"><span data-stu-id="ed4ae-218">Control asset caching</span></span>

<span data-ttu-id="ed4ae-219">如果你的项目定义了一个名为 `ServiceWorkerAssetsManifest` 的MSBuild 属性，则 Blazor 的生成工具将生成具有指定名称的服务工作进程资产清单。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-219">If your project defines an MSBuild property called `ServiceWorkerAssetsManifest`, then Blazor's build tooling will generate a service worker assets manifest with the specified name.</span></span> <span data-ttu-id="ed4ae-220">默认 PWA 模板生成包含以下内容的项目文件：</span><span class="sxs-lookup"><span data-stu-id="ed4ae-220">The default PWA template produces a project file containing the following:</span></span>

```xml
<ServiceWorkerAssetsManifest>service-worker-assets.js</ServiceWorkerAssetsManifest>
```

<span data-ttu-id="ed4ae-221">该文件位于“wwwroot”输出目录中，因此浏览器可以通过请求 `/service-worker-assets.js` 检索此文件。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-221">The file is placed in the *wwwroot* output directory, so the browser can retrieve this file by requesting `/service-worker-assets.js`.</span></span> <span data-ttu-id="ed4ae-222">要查看内容，请在文本编辑器中打开 YourProject\bin\Debug\netstandard2.1\wwwroot\service-worker-assets.js。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-222">To see the contents, open *YourProject\bin\Debug\netstandard2.1\wwwroot\service-worker-assets.js* in a text editor.</span></span> <span data-ttu-id="ed4ae-223">不过，请不要编辑该文件，因为它会在每次生成时重新生成。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-223">However, don't edit the file, as it will be regenerated on each build.</span></span>

<span data-ttu-id="ed4ae-224">默认情况下，此清单列出：</span><span class="sxs-lookup"><span data-stu-id="ed4ae-224">By default, this manifest lists:</span></span>

* <span data-ttu-id="ed4ae-225">任何 Blazor 管理的资源（如 .NET 程序集）以及脱机工作所需的 .NET WebAssembly 运行时文件</span><span class="sxs-lookup"><span data-stu-id="ed4ae-225">Any Blazor-managed resources such as .NET assemblies and the .NET WebAssembly runtime files needed to function offline</span></span>
* <span data-ttu-id="ed4ae-226">要在 wwwroot 目录中发布的所有资源，如图像、CSS 文件和 JavaScript 文件。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-226">All resources that will be published in your *wwwroot* directory, such as images, CSS files, and JavaScript files.</span></span> <span data-ttu-id="ed4ae-227">这包括外部项目和 NuGet 包提供的静态 Web 资产。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-227">This includes static web assets supplied by external projects and NuGet packages.</span></span>

<span data-ttu-id="ed4ae-228">可通过编辑 service-worker.published.js 中 `onInstall` 中的逻辑，控制哪些资源将由服务工作进程提取和缓存。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-228">You can control which of these resources will be fetched and cached by the service worker by editing the logic in `onInstall` in *service-worker.published.js*.</span></span> <span data-ttu-id="ed4ae-229">默认情况下，它将提取并缓存与典型 Web 文件扩展名匹配的文件，例如 .html、.css、.js、.wasm 等文件，以及特定于 Blazor WebAssembly 的文件类型（.dll、.pdb）。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-229">By default, it will fetch and cache files matching typical web filename extensions such as *.html*, *.css*, *.js*, *.wasm*, and others, plus file types specific to Blazor WebAssembly (*.dll*, *.pdb*).</span></span>

<span data-ttu-id="ed4ae-230">如果你希望包括 wwwroot 目录中不存在的其他资源，可通过定义额外的 MSBuild 项目组条目来实现。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-230">If you want to include additional resources that aren't present in your *wwwroot* directory, you can do so by defining extra MSBuild itemgroup entries.</span></span> <span data-ttu-id="ed4ae-231">例如，在项目文件中，添加：</span><span class="sxs-lookup"><span data-stu-id="ed4ae-231">For example, in your project file, add:</span></span>

```xml
<ItemGroup>
    <ServiceWorkerAssetsManifestItem
        Include="MyDirectory\AnotherFile.json"
        RelativePath="MyDirectory\AnotherFile.json"
        AssetUrl="files/AnotherFile.json" />
</ItemGroup>
```

<span data-ttu-id="ed4ae-232">`AssetUrl` 元数据指定了在提取要缓存的资源时浏览器应使用的基相对 URL。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-232">The `AssetUrl` metadata specifies the base-relative URL that the browser should use when fetching the resource to cache.</span></span> <span data-ttu-id="ed4ae-233">它可以独立于磁盘上的原始源文件名。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-233">This can be independent of its original source file name on disk.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="ed4ae-234">添加 `ServiceWorkerAssetsManifestItem` 不会导致文件发布到 wwwroot 目录。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-234">Adding a `ServiceWorkerAssetsManifestItem` does not cause the file to be published in your *wwwroot* directory.</span></span> <span data-ttu-id="ed4ae-235">你可以单独控制发布输出。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-235">It up to you to control your publish output separately.</span></span> <span data-ttu-id="ed4ae-236">`ServiceWorkerAssetsManifestItem` 仅导致服务工作进程清单中出现一个额外条目。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-236">The `ServiceWorkerAssetsManifestItem` only causes an additional entry to appear in the service worker assets manifest.</span></span>

## <a name="push-notifications"></a><span data-ttu-id="ed4ae-237">推送通知</span><span class="sxs-lookup"><span data-stu-id="ed4ae-237">Push notifications</span></span>

<span data-ttu-id="ed4ae-238">与任何其他 PWA 一样，Blazor WebAssembly PWA 可以从后端服务器接收推送通知。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-238">Like any other PWA, a Blazor WebAssembly PWA can receive push notifications from a backend server.</span></span> <span data-ttu-id="ed4ae-239">你的服务器可以随时发送这些通知，即使用户未积极使用应用程序（例如，当其他用户执行可能相关的操作时）。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-239">Your server can send these at any time, even when the user is not actively using your application (for example, when a different user performs an action that may be relevant).</span></span>

<span data-ttu-id="ed4ae-240">发送推送通知的机制完全独立于 Blazor WebAssembly，因为它是由可以使用任何技术的后端服务器实现的。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-240">The mechanism for sending a push notification is entirely independent of Blazor WebAssembly, since it's implemented by the backend server which can use any technology.</span></span> <span data-ttu-id="ed4ae-241">如果你想要从 ASP.NET Core 服务器发送推送通知，请考虑[使用类似于 Blazing Pizza 研讨会中的技术](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#sending-push-notifications)。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-241">If you want to send push notifications from an ASP.NET Core server, consider [using a technique similar to that in the Blazing Pizza workshop](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#sending-push-notifications).</span></span>

<span data-ttu-id="ed4ae-242">在客户端上接收和显示推送通知的机制也独立于 Blazor WebAssembly，因为它是在服务工作进程（即 JavaScript 文件）中实现的。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-242">The mechanism for receiving and displaying a push notification on the client is also independent of Blazor WebAssembly, since it's implemented in the service worker, which is a JavaScript file.</span></span> <span data-ttu-id="ed4ae-243">例如，你可以再次查看[在 Blazing Pizza 研讨会中使用的方法](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#displaying-notifications)。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-243">As an example, you can again see [the approach used in the Blazing Pizza workshop](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#displaying-notifications).</span></span>

## <a name="caveats-for-offline-pwas"></a><span data-ttu-id="ed4ae-244">脱机 PWA 的注意事项</span><span class="sxs-lookup"><span data-stu-id="ed4ae-244">Caveats for offline PWAs</span></span>

<span data-ttu-id="ed4ae-245">并非所有应用程序都应尝试支持脱机使用。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-245">Not all applications should attempt to support offline use.</span></span> <span data-ttu-id="ed4ae-246">它增加了很大的复杂性，但有时并没有必要。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-246">It adds significant complexity, while not always being relevant.</span></span>

<span data-ttu-id="ed4ae-247">脱机支持通常仅适用于：</span><span class="sxs-lookup"><span data-stu-id="ed4ae-247">Offline support is usually relevant only:</span></span>

* <span data-ttu-id="ed4ae-248">如果主数据存储是浏览器的本地数据存储。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-248">If your primary data store is local to the browser.</span></span> <span data-ttu-id="ed4ae-249">例如，为将数据存储在 `localStorage` 或 [IndexedDB](https://developer.mozilla.org/docs/Web/API/IndexedDB_API) 中的 [IoT](https://en.wikipedia.org/wiki/Internet_of_things) 设备生成 UI 时。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-249">For example, when building a UI for an [IoT](https://en.wikipedia.org/wiki/Internet_of_things) device that stores data in `localStorage` or [IndexedDB](https://developer.mozilla.org/docs/Web/API/IndexedDB_API).</span></span>

* <span data-ttu-id="ed4ae-250">如果你执行大量工作来提取和缓存与每个用户相关的后端 API 数据，则他们可以脱机浏览。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-250">If you do significant work to fetch and cache the backend API data relevant to each user, so they can navigate through it offline.</span></span> <span data-ttu-id="ed4ae-251">如果你支持编辑，你还需要生成一个系统来跟踪更改，并将其与后端同步。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-251">If you support editing, you will also need to build a system for tracking changes and synchronizing them with the backend.</span></span>

* <span data-ttu-id="ed4ae-252">如果你的目标是在不考虑网络状况的情况下保证应用程序立即加载，</span><span class="sxs-lookup"><span data-stu-id="ed4ae-252">If your goal is to guarantee the application loads immediately regardless of network conditions.</span></span> <span data-ttu-id="ed4ae-253">则你需要对后端 API 请求实现适当的用户体验，以显示请求的进度，并在请求因网络不可用而失败时妥善处理。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-253">You will then need to implement a suitable user experience around backend API requests to show the progress of requests and behave gracefully when they fail due to network unavailability.</span></span>

<span data-ttu-id="ed4ae-254">此外，支持脱机的 PWA 需要处理一系列额外的复杂操作。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-254">Additionally, offline-capable PWAs need to deal with a range of extra complications.</span></span> <span data-ttu-id="ed4ae-255">开发人员应认真熟悉以下注意事项。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-255">Developers should carefully familiarize themselves with the following caveats.</span></span>

### <a name="offline-support-only-when-published"></a><span data-ttu-id="ed4ae-256">仅在发布后支持脱机</span><span class="sxs-lookup"><span data-stu-id="ed4ae-256">Offline support only when published</span></span>

Blazor<span data-ttu-id="ed4ae-257"> 的 PWA 模板仅在发布后启用脱机支持。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-257">'s PWA template enables offline support only when published.</span></span> <span data-ttu-id="ed4ae-258">这是因为，在开发过程中，你通常希望看到各项更改立即反映在浏览器中，而无需经过后台更新过程。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-258">This is because, during development, you typically want to see each change reflected immediately in the browser, without going through a background update process.</span></span>

<span data-ttu-id="ed4ae-259">因此，在生成支持脱机的应用程序时，在开发模式下测试应用程序是不够的。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-259">Therefore when building an offline-capable application, it's not enough to test your application in development mode.</span></span> <span data-ttu-id="ed4ae-260">必须在已发布状态下测试应用程序，了解它如何响应不同的网络情况。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-260">You must test your application in its published state to understand how it will respond to differing network conditions.</span></span>

### <a name="update-completion-after-user-navigation-away-from-app"></a><span data-ttu-id="ed4ae-261">用户导航离开应用后完成更新</span><span class="sxs-lookup"><span data-stu-id="ed4ae-261">Update completion after user navigation away from app</span></span>

<span data-ttu-id="ed4ae-262">用户导航离开了应用程序的所有选项卡后，更新才会完成。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-262">Updates don't complete until the user has navigated away from your application in all tabs.</span></span> <span data-ttu-id="ed4ae-263">如[后台更新](#background-updates)中所述，在你将更新部署到应用程序后，浏览器将提取更新后的服务工作进程文件并开始更新过程。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-263">As explained in [Background updates](#background-updates), after you deploy an update to your application, the browser will fetch the updated service worker files and begin an update process.</span></span>

<span data-ttu-id="ed4ae-264">令许多开发人员惊讶的是，即使此更新完成，在用户导航离开所有选项卡之前，它也不会生效。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-264">What surprises many developers is that, even when this update completes, it does **not** take effect until the user has navigated away in all tabs.</span></span> <span data-ttu-id="ed4ae-265">刷新显示应用程序的选项卡也不行，即使它是显示应用程序的唯一选项卡。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-265">It is **not** sufficient to refresh the tab displaying your application, even if it's the only tab displaying your application.</span></span> <span data-ttu-id="ed4ae-266">在应用程序完全关闭之前，新的服务工作进程将保持“正在等待激活”状态。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-266">Until your application is completely closed, the new service worker will remain in a "waiting to activate" status.</span></span> <span data-ttu-id="ed4ae-267">这并不特定于 Blazor，而是标准 Web 平台行为。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-267">**This is not specific to Blazor, but rather is a standard web platform behavior.**</span></span>

<span data-ttu-id="ed4ae-268">这通常会给试图测试对其服务工作进程或脱机缓存资源的更新的开发人员造成麻烦。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-268">This commonly troubles developers who are trying to test updates to their service worker or offline cached resources.</span></span> <span data-ttu-id="ed4ae-269">如果你签入浏览器的开发工具，可能会看到如下所示的内容：</span><span class="sxs-lookup"><span data-stu-id="ed4ae-269">If you check in the browser's dev tools, you may see something like the following:</span></span>

![图像](https://user-images.githubusercontent.com/1101362/76226394-b93f7380-6215-11ea-8572-7d52afee2dd8.png)

<span data-ttu-id="ed4ae-271">只要“客户端”列表（即显示应用程序的标签或窗口）不为空，工作进程就会继续等待。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-271">For as long as the list of "clients" (i.e., tabs or windows displaying your application) is nonempty, the worker will continue waiting.</span></span> <span data-ttu-id="ed4ae-272">服务工作进程这样做的原因是为了保证一致性，即所有资源均提取自同一原子缓存。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-272">The reason service workers do this is to guarantee consistency, i.e., that all resources are fetched from the same atomic cache.</span></span>

<span data-ttu-id="ed4ae-273">测试更改时，你可能会发现，单击如上面的屏幕截图中所示的“skipWaiting”链接，然后重载页面，这样操作会比较方便。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-273">When testing changes, you may find it convenient to click the "skipWaiting" link as shown in the screenshot above, then reload the page.</span></span> <span data-ttu-id="ed4ae-274">如果需要，你可以通过以下方式为所有用户自动实现此操作：对服务工作进程进行编码，[跳过“等待”阶段并在更新时立即激活](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#skip_the_waiting_phase)。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-274">If you want, you can automate this for all users by coding your service worker to [skip the "waiting" phase and immediately activate on update](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#skip_the_waiting_phase).</span></span> <span data-ttu-id="ed4ae-275">但是，如果这样做，你无法保证资源始终一致地提取自同一缓存实例。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-275">However if you do this, you are giving up the guarantee that resources are always fetched consistently from the same cache instance.</span></span>

### <a name="users-may-run-any-historical-version-of-the-app"></a><span data-ttu-id="ed4ae-276">用户可以运行应用的任何历史版本</span><span class="sxs-lookup"><span data-stu-id="ed4ae-276">Users may run any historical version of the app</span></span>

<span data-ttu-id="ed4ae-277">Web 开发人员习惯性地期望用户仅运行其 Web 应用程序的最新部署版本，因为在传统的 Web 分发模型中这是正常现象。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-277">Web developers habitually expect that users will only run the latest deployed version of their web application, since that's normal within the traditional web distribution model.</span></span> <span data-ttu-id="ed4ae-278">但是，脱机优先 PWA 更类似于本机移动应用，用户不必运行最新版本。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-278">However, an offline-first PWA is more akin to a native mobile app, where users are not necessarily running the latest version.</span></span>

<span data-ttu-id="ed4ae-279">如[后台更新](#background-updates)中所述，在你将更新部署到应用程序后，每个现有用户将继续使用以前的版本，至少再进行一次访问（因为更新在后台进行，且在用户离开后才会激活）。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-279">As explained in [Background updates](#background-updates), after you deploy an update to your application, **each existing user will continue to use a previous version for at least one further visit** (because the update occurs in the background and isn't activated until the user then navigates away).</span></span> <span data-ttu-id="ed4ae-280">此外，使用的先前版本不一定是你部署的上一个版本 - 它可以是任何历史版本，具体取决于用户上次完成更新的时间。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-280">Plus, the previous version being used isn't necessarily the previous one you deployed - it can be *any* historical version, depending on when the user last completed an update.</span></span>

<span data-ttu-id="ed4ae-281">如果应用程序的前端和后端部分需要就 API 请求的架构达成一致，这可能是一个问题。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-281">This can be an issue if the frontend and backend parts of your application require agreement about the schema for API requests.</span></span> <span data-ttu-id="ed4ae-282">你须先确保所有用户都已升级，或者至少可阻止用户使用不兼容的旧版应用，才能部署后向不兼容的 API 架构变更。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-282">You must not deploy backward-incompatible API schema changes until you can be sure that all users have upgraded, or at least block users from using incompatible older versions of the app.</span></span> <span data-ttu-id="ed4ae-283">这与本机移动应用类似。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-283">This is just like a native mobile app.</span></span> <span data-ttu-id="ed4ae-284">如果在服务器 API 中部署中断性变更，则尚未更新的用户的客户端应用将中断。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-284">If you deploy a breaking change in server APIs, the client app will be broken for people who haven't yet updated.</span></span>

<span data-ttu-id="ed4ae-285">如果可以，请勿将中断性变更部署到后端 API。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-285">If possible, don't deploy breaking changes to your backend APIs.</span></span> <span data-ttu-id="ed4ae-286">但如果必须这样做，请考虑使用[标准服务工作进程 API（如 `ServiceWorkerRegistration`）](https://developer.mozilla.org/docs/Web/API/ServiceWorkerRegistration)，确定应用程序是否为最新版本；如果不是，则阻止使用。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-286">But if you must do so, consider using [standard Service Worker APIs such as `ServiceWorkerRegistration`](https://developer.mozilla.org/docs/Web/API/ServiceWorkerRegistration) to determine whether the application is up-to-date, and if not, to prevent usage.</span></span>

### <a name="interference-with-server-rendered-pages"></a><span data-ttu-id="ed4ae-287">干扰服务器呈现的页面</span><span class="sxs-lookup"><span data-stu-id="ed4ae-287">Interference with server-rendered pages</span></span>

<span data-ttu-id="ed4ae-288">[如上所述](#support-server-rendered-pages)，若你要绕过服务工作进程为所有导航请求返回 `/index.html` 内容的行为，需要在服务工作进程中编辑该逻辑。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-288">[As described above](#support-server-rendered-pages), if you want to bypass the service worker's behavior of returning `/index.html` contents for all navigation requests, you need to edit the logic in your service worker.</span></span>

### <a name="all-service-worker-asset-manifest-contents-are-cached-by-default"></a><span data-ttu-id="ed4ae-289">默认缓存所有服务工作进程资产清单内容</span><span class="sxs-lookup"><span data-stu-id="ed4ae-289">All service worker asset manifest contents are cached by default</span></span>

<span data-ttu-id="ed4ae-290">[如上所述](#control-asset-caching)，文件 service-worker-assets.js 是在生成过程中产生的，并且列出了服务工作进程应提取和缓存的所有资产。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-290">[As described above](#control-asset-caching), the file *service-worker-assets.js* is generated during build and lists all assets the service worker should fetch and cache.</span></span>

<span data-ttu-id="ed4ae-291">由于此列表默认包含发出到 wwwroot 的所有内容（包括外部包和项目提供的内容），因此必须注意不要将太多内容放在此处。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-291">Since this list by default includes everything emitted to *wwwroot* (including content supplied by external packages and projects), you must be careful not to put too much content there.</span></span> <span data-ttu-id="ed4ae-292">例如，如果你的 wwwroot 目录包含数百万个图像，服务工作进程会尝试提取并缓存它们，这会消耗过多的带宽，并且很可能无法成功完成。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-292">If for example your *wwwroot* directory contains millions of images, the service worker would try to fetch and cache them all, consuming excessive bandwidth and most likely not completing successfully.</span></span>

<span data-ttu-id="ed4ae-293">可以通过编辑 service-worker.published.js 中的 `onInstall` 函数，实现任意逻辑以控制应提取和缓存清单内容的哪个子集。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-293">You can implement arbitrary logic to control which subset of the manifest's contents should be fetched and cached by editing the `onInstall` function in *service-worker.published.js*.</span></span>

### <a name="interaction-with-authentication"></a><span data-ttu-id="ed4ae-294">与身份验证交互</span><span class="sxs-lookup"><span data-stu-id="ed4ae-294">Interaction with authentication</span></span>

<span data-ttu-id="ed4ae-295">可以结合使用 PWA 模板选项和身份验证选项。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-295">It's possible to use the PWA template option in conjunction with the authentication options.</span></span> <span data-ttu-id="ed4ae-296">在用户具有网络连接时，支持脱机的 PWA 还可以支持身份验证。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-296">An offline-capable PWA can also support authentication when the user has network connectivity.</span></span>

<span data-ttu-id="ed4ae-297">但是，当用户没有网络连接时，他们将无法进行身份验证或获取访问令牌。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-297">However, when a user does not have network connectivity, they will not be able to authenticate or obtain access tokens.</span></span> <span data-ttu-id="ed4ae-298">尝试访问“登录”页会默认显示一条指示“网络错误”的消息。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-298">Attempting to visit the "login" page will by default display a message saying "network error".</span></span>

<span data-ttu-id="ed4ae-299">因此，你的工作就是设计一个 UI 流，使用户能够在脱机时执行实用的操作，而无需尝试进行身份验证或获取访问令牌，或者至少在这些情况下妥善地提示操作失败。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-299">As such it's your job to design a UI flow that lets the user do useful things while offline without attempting to authenticate or obtain access tokens, or at least failing in a graceful way in those cases.</span></span> <span data-ttu-id="ed4ae-300">如果这在你的应用程序中不可行，你可能不希望启用脱机支持。</span><span class="sxs-lookup"><span data-stu-id="ed4ae-300">If this isn't possible in your application, you might not want to enable offline support.</span></span>
